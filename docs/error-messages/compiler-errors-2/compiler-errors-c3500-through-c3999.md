---
title: "Compilerfehler Fehler C3500 über C3999 | Microsoft Docs"
ms.date: 11/17/2017
ms.technology:
- cpp-tools
ms.topic: error-reference
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
dev_langs:
- C++
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 7a34b3f3fb635cc666b0e9cca079373bb7c5636e
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/21/2017
---
# <a name="compiler-errors-c3500-through-c3999"></a>Compilerfehler Fehler C3500 über C3999

Die Artikel in diesem Abschnitt der Dokumentation wird erläutert, eine Teilmenge der Fehlermeldungen, die vom Compiler generiert werden.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Fehlermeldungen

|Fehler|Meldung|
|-----------|-------------|
|[Compilerfehler C3500](compiler-error-c3500.md)|Ungültiges ProgID "*progid*"|
|[Compilerfehler C3501](compiler-error-c3501.md)|Es ist keine Typbibliothek registriert, die für die ProgID "*progid*"|
|Compilerfehler Fehler C3502|LIBID kann nicht abgerufen werden, für die ProgID "*progid*"|
|Compilerfehler Fehler C3503|Zeichen "0 X*Wert*" ist nicht zulässig in einer unformatierten Zeichenfolge literal|
|Compilerfehler Fehler C3504|GUID kann nicht erstellt werden, die aus einer Zeichenfolge "*Zeichenfolge*"|
|[Compilerfehler C3505](compiler-error-c3505.md)|Typbibliothek kann nicht geladen werden "*Bibliothek*"|
|[Compilerfehler C3506](compiler-error-c3506.md)|Es ist keine Typbibliothek für LIBID registriert "*Bibliothek*"|
|[Compilerfehler C3507](compiler-error-c3507.md)|eine ProgID kann nicht mehr als 39 Zeichen haben*progid*"; noch Satzzeichen außer enthalten '.'; noch mit einer Ziffer beginnen|
|[Compilerfehler C3508](compiler-error-c3508.md)|"*Typ*": ist kein gültiger Automationstyp|
|[Compilerfehler C3509](compiler-error-c3509.md)|"*Typ*": Ungültiger Automation Rückgabetyp; Wenn ein Parameter 'Retval' gekennzeichnet ist, der Rückgabetyp muss 'void', 'HRESULT' oder 'SCODE'|
|[Compilerfehler C3510](compiler-error-c3510.md)|abhängige Typbibliothek nicht gefunden *Bibliothek*|
|Compilerfehler Fehler C3511|"*Bezeichner*": ein Aufruf eines Konstruktors eines delegierenden muss die einzige Memberinitialisierer|
|Compilerfehler Fehler C3512|die begrenzenden Zeichensequenz für ein unformatiertes Zeichenfolgenliteral darf nicht mehr als 16 Zeichen haben.|
|Compilerfehler Fehler C3513|"*Zeichenfolge*': nicht unterstützte rohzeichenfolge Zeichenfolgenliteral-Trennzeichen|
|Compilerfehler Fehler C3514|"*Zeichen*" (*Wert*): nicht unterstützte rohzeichenfolge Zeichenfolgenliteral-Trennzeichen|
|Compilerfehler Fehler C3515|ein Argument für eine teilweise Spezialisierung einer Klassenvorlage ist eine paketerweiterung muss es das letzte Argument sein.|
|Compilerfehler Fehler C3516|Unerwarteter-Dateiende bei der Verarbeitung der unformatierten Zeichenfolgenliterals gefunden; Trennzeichen-Reihenfolge "*Zeichenfolge*" nicht abgeglichen wurde|
|Compiler-Fehler C3517 generiert|"*Bezeichner*" eine Aliasdeklaration keinen Typ, der "auto" enthält|
|Compilerfehler Fehler C3518|"*Bezeichner*': in einem Kontext listeninitialisierung direkt der Typ für '*Typ*' können nur über einen einzelnen Initialisierungsausdruck abgeleitet werden|
|[Compilerfehler C3519](compiler-error-c3519.md)|"*Parameter*": Ungültiger Parameter für Embedded_idl-Attribut|
|Compilerfehler Fehler C3520|"*Bezeichner*': in diesem Kontext muss parameterpaket erweitert werden|
|Compilerfehler Fehler C3521|"*Bezeichner*' ist kein parameterpaket|
|Compilerfehler Fehler C3522|"*Typ*': parameterpaket kann nicht in diesem Kontext nicht erweitert werden|
|Compilerfehler Fehler C3523|"..." sizeof "" als Argument ein nicht erweiterte parameterpaket erfordert|
|Compilerfehler Fehler C3524|"*Bezeichner*": "Sizeof" kann nicht auf ein parameterpaket angewendet werden. Meinten Sie '... "sizeof"' verwenden?|
|Compilerfehler Fehler C3525|"*Parameter*": Wenn eine Klassenvorlage ein parameterpaket Vorlage verfügt, muss es am Ende der Vorlagenparameterliste angezeigt werden,|
|Compilerfehler Fehler C3526|"..." kann nicht zu "this" nicht angewendet werden|
|Compilerfehler Fehler C3527|"*Bezeichner*" ist keinem gültigen Operand für "..."sizeof"". Meinten Sie "Sizeof" zu verwenden?|
|Compilerfehler Fehler C3528|"*Bezeichner1*": die Anzahl der Elemente in dieser paketerweiterung entspricht nicht der Anzahl der Elemente im "*Bezeichner2*"|
|Compilerfehler Fehler C3529|"*Parameter*": ein parameterpaket Vorlage keine Standardargument|
|[Compilerfehler C3530](compiler-error-c3530.md)|"*Typ*" kann nicht mit einem anderen Typspezifizierer kombiniert werden|
|[Compilerfehler C3531](compiler-error-c3531.md)|"*Bezeichner*": ein Symbol, dessen Typ enthält "*Typ*" muss einen Initialisierer haben|
|[Compilerfehler C3532](compiler-error-c3532.md)|der Elementtyp eines Arrays handelt es sich nicht um einen Typ mit "*Typ*"|
|[Compilerfehler C3533](compiler-error-c3533.md)|ein Parameter keinen Typ, die enthält "*Typ*"|
|Compilerfehler C3534|Veraltet.|
|[Compilerfehler C3535](compiler-error-c3535.md)|Typ nicht ableiten "*Typ1*"from"*Typ2*"|
|[Compilerfehler C3536](compiler-error-c3536.md)|"*Bezeichner*": kann nicht vor der Initialisierung verwendet werden|
|[Compilerfehler C3537](compiler-error-c3537.md)|Sie können nicht eine Umwandlung in einen Typ mit "*Typ*"|
|[Compilerfehler C3538](compiler-error-c3538.md)|in einer Deklaratorliste "*Typ*" muss immer in denselben Typ hergeleitet werden|
|[Compilerfehler C3539](compiler-error-c3539.md)|ein Vorlagenargument handelt es sich nicht um einen Typ mit "*Typ*"|
|[Compilerfehler C3540](compiler-error-c3540.md)|"sizeof" kann nicht angewendet werden, um einen Typ mit "*Typ*"|
|[Compilerfehler C3541](compiler-error-c3541.md)|Typeid kann nicht angewendet werden, um einen Typ mit "*Typ*"|
|Compilerfehler Fehler C3542|"*Bezeichner*': eine virtuelle Memberfunktion hat einen Rückgabetyp aufweisen, die enthält nicht"*Typ*"|
|Compilerfehler Fehler C3543|"*Typ*": enthält kein parameterpaket|
|Compilerfehler Fehler C3544|"*Parameter*": parameterpaket erwartet, dass eine Vorlage-Typargument|
|Compilerfehler Fehler C3545|"*Parameter*": parameterpaket erwartet ein Vorlagenargument Nichttyp-|
|Compilerfehler Fehler C3546|"...": Es gibt keine parameterpaketen verfügbar zu erweitern|
|Compilerfehler Fehler C3547|Vorlagenparameter "*Parameter*"kann nicht verwendet werden, da es ein parameterpaket Vorlage folgt und nicht werden, aus der Funktionsparameter abgeleitet kann"*Funktion*"|
|Compilerfehler Fehler C3548|"*Bezeichner*': parameterpaket kann nicht in diesem Kontext nicht verwendet werden|
|Compilerfehler Fehler C3549|"*Wert*": ein parameterpaket Funktion sind keine Standardargument|
|[Compilerfehler C3550](compiler-error-c3550.md)|In diesem Kontext ist nur ein einfaches "decltype(auto)" zulässig.|
|[Compilerfehler C3551](compiler-error-c3551.md)|Wenn Sie ein nachstehenden Rückgabetyp verwendet wird, und klicken Sie dann die führende Rückgabetyp muss der einzelnen Typspezifizierer 'Auto' sein (nicht "*Typ*")|
|[Compilerfehler C3552](compiler-error-c3552.md)|erwartete "decltype(Auto)""|
|[Compilerfehler C3553](compiler-error-c3553.md)|"decltype" erwartet einen Ausdruck und keinen Typ.|
|[Compilerfehler C3554](compiler-error-c3554.md)|"*Typ*" kann nicht mit einem anderen Typspezifizierer kombiniert werden|
|[Compilerfehler C3555](compiler-error-c3555.md)|Falsches Argument für "decltype"|
|[Compilerfehler C3556](compiler-error-c3556.md)|"*Ausdruck*': falsches Argument für"Decltype"|
|Compilerfehler C3557|Veraltet.|
|Compilerfehler C3558|Veraltet.|
|Compilerfehler Fehler C3559|rekursiver Aufruf von "*Funktion*": Rekursion wird beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each am erkannt: '*Funktion*"|
|Compilerfehler Fehler C3560|"*Funktion*": IL ist nicht verfügbar, beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each an: "*Funktion*"|
|Compilerfehler Fehler C3561|Kachel Barrier-Vorgang wurde in der ablaufsteuerung, der nicht einheitliche Kachel beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each am gefunden: "*Funktion*"|
|Compilerfehler Fehler C3562|systeminterne Funktion "*Funktion*" ist nicht auf mehr als *Anzahl* Parameter|
|Compilerfehler Fehler C3563|Endlosschleife, die beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each am erkannt: '*Funktion*"|
|Compilerfehler Fehler C3564|Lesen von nicht initialisierten Wert beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each an: "*Funktion*"|
|Compilerfehler Fehler C3565|Die Gesamtmenge des Arbeitsspeichers von "tile_static" (*Anzahl* Bytes) überschreitet den Grenzwert von *Anzahl* Bytes, die beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each|
|Compilerfehler Fehler C3566|Blöcke mit Nebeneffekten sind zu tief geschachtelt, wenn für das Concurrency:: parallel_for_each am Diagramm kompilieren den Aufruf: "*Funktion*"|
|Compilerfehler Fehler C3567|Division oder Modulo durch 0 (null), die beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each am erkannt: '*Funktion*"|
|Compilerfehler Fehler C3568|Summe der Register überschreitet den Grenzwert von *Anzahl* beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each. Vereinfachen Sie Ihr Programm|
|Compilerfehler Fehler C3569|Racebedingung beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each am erkannt: '*Funktion*"|
|Compilerfehler Fehler C3570|Unzulässige Verwendung des Amp eingeschränkten Bereich beim Kompilieren mit/CLR|
|Compilerfehler Fehler C3571|"*Typ*': Unzulässiger Compute-Domäne-Argument; nicht in einen Klassentyp|
|Compilerfehler Fehler C3572|"*Typ*': Unzulässiger Compute-Domäne-Argument; fehlenden öffentliche Member:"static const Int Rang"oder Rangwert ist nicht positiver Wert|
|Compilerfehler Fehler C3573|Die Anzahl der Instanzen des Concurrency::graphics::sampler Concurrency:: parallel_for_each übergeben nicht überschreiten *Anzahl*|
|Compilerfehler Fehler C3574|"*Typ*': Unzulässiger Kachel Blöcken: muss positiv und (1) Z < = *Anzahl*; (2) Z*Y*X < = *Anzahl*|
|Compilerfehler Fehler C3575|"*Typ*': Unzulässiger Compute-Domäne-Argument; fehlenden öffentliche Member:" concurrency::index <*Anzahl*> _map_index (const concurrency::index <*Anzahl*> &) restrict(amp) "|
|Compilerfehler Fehler C3576|"*Typ*": Concurrency::details::_Parallel_for_each Argument #*Anzahl* weist den nicht unterstützten Typ|
|Compilerfehler Fehler C3577|Concurrency:: parallel_for_each-Kernel-Argument ist ungültig: Aufruf von Member kann nicht aufgelöst werden. "" void "Operator()" (*Typ*) restrict(amp) "|
|Compilerfehler Fehler C3578|Die Größe des Funktionsobjekts übergeben Concurrency:: parallel_for_each nicht überschreiten *Anzahl* Bytes|
|Compilerfehler Fehler C3579|Die schreibgeschützte Instanzen von Concurrency:: Array und Concurrency::graphics::texture Concurrency:: parallel_for_each übergeben darf nicht mehr als *Anzahl*|
|Compilerfehler Fehler C3580|Die beschreibbaren Instanzen von Concurrency:: Array und Concurrency::graphics::texture Concurrency:: parallel_for_each übergeben darf nicht mehr als *Anzahl*|
|Compilerfehler Fehler C3581|"*Typ*': nicht unterstützter Typ im Amp eingeschränkt Code|
|Compilerfehler Fehler C3582|Veraltet.|
|Compilerfehler Fehler C3583|"*Bezeichner*": die Größe der Variablen (*Anzahl* Bytes) ist größer als die maximale Größe (*Anzahl* Bytes) in eingeschränkten ampcode unterstützt.|
|Compilerfehler Fehler C3584|nicht unterstützte Verwendung von "tile_static" auf "*Bezeichner*"|
|Compilerfehler Fehler C3585|"*Bezeichner*" verfügt über nicht unterstützte Speicherklasse in Amp eingeschränkte Code|
|Compilerfehler Fehler C3586|"*Bezeichner*': Verwendung von globalen oder statischen Variablen wird nicht unterstützt werden, in eingeschränkten Amp-Code|
|Compilerfehler Fehler C3587|Dynamic_cast wird in eingeschränkten Amp-Code nicht unterstützt.|
|Compilerfehler Fehler C3588|Umwandlung von '*Typ1*'to'*Typ2*"wird in einer eingeschränkten Amp-Code nicht unterstützt|
|Compilerfehler Fehler C3589|"*Zeichenfolge*': nicht unterstützte Verwendung von Zeichenfolgenliteralen in Amp eingeschränkt Code|
|Compilerfehler Fehler C3590|"*token*': als Verweis erfassen oder 'this' Capture wird nicht unterstützt, wenn der Lambda-Ausdruck Amp beschränkt ist|
|Compilerfehler Fehler C3591|Typeid-Operator wird in eingeschränkten Amp-Code nicht unterstützt.|
|Compilerfehler Fehler C3592|Systemeigene Inlineassembly ("__asm") wird in eingeschränkten Amp-Code nicht unterstützt.|
|Compilerfehler Fehler C3593|"Goto" ist in eingeschränkten Amp-Code nicht unterstützt.|
|Compilerfehler Fehler C3594|Ausnahmebehandlung (Try, Catch, Throw usw.) wird in eingeschränkten Amp-Code nicht unterstützt.|
|Compilerfehler Fehler C3595|konstanter Wert liegt außerhalb des unterstützten Bereichs in eingeschränkten Amp-code|
|Compilerfehler Fehler C3596|"*Parameter*" ("*Typ*"): Variablen, die vom Lambda erfasst weist den nicht unterstützten Typ im eingeschränkten ampcode|
|Compilerfehler Fehler C3597|"*Parameter*": "*Bezeichner*" darf nicht als Wert erfasst werden, wenn der Lambda-Ausdruck Amp beschränkt ist|
|Compilerfehler Fehler C3598|Label-Anweisung wird in eingeschränkten Amp-Code nicht unterstützt.|
|Compilerfehler Fehler C3599|"*Operator*': Zeigerarithmetik kann nicht auf Zeiger in bool konvertiert in eingeschränkten Amp-Code|
|Compilerfehler Fehler C3600|"*Funktion*": Verwenden der Kachel "\_statischer Arbeitsspeicher beim Kompilieren des Aufrufdiagramms für die nicht Tiling concurrency::parallel erkannt\_For_each an:"*Funktion*"|
|Compilerfehler Fehler C3601|"*Typ*': Ungültiges Argument für die Diagnose Amp-Funktion ist"*Funktion*"|
|Compilerfehler Fehler C3602|Nicht unterstützte ablaufsteuerung, die beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each am erkannt: '*Funktion*"|
|[Compilerfehler C3603](compiler-error-c3603.md)|"*Symbol*': Typ"*Typ*"noch nicht unterstützt.|
|Compilerfehler Fehler C3604|"*Bezeichner*": ein verwaltetes Objekt kann nur auf dem gc-Heap erstellen|
|Compilerfehler Fehler C3605|Die Gesamtanzahl der Sampler (*Anzahl* erfasst und *Anzahl* vordefinierte) überschreiten *Anzahl* beim Kompilieren des Aufrufdiagramms für das Concurrency:: parallel_for_each an: " *Funktion*"|
|Compilerfehler Fehler C3606|Veraltet.|
|Compilerfehler Fehler C3607|Veraltet.|
|Compilerfehler Fehler C3608|Veraltet.|
|[Compilerfehler C3609](compiler-error-c3609.md)|"*Bezeichner*': eine ' versiegelt/endgültige'-Funktion muss virtuell sein|
|[Compilerfehler C3610](compiler-error-c3610.md)|"*Bezeichner*": Werttyp muss vor der Methode "geschachtelt" werden "*Methode*' aufgerufen werden kann|
|[Compilerfehler C3611](compiler-error-c3611.md)|"*Bezeichner*': eine versiegelte Funktion sind keine pure-Specifier|
|[Compilerfehler C3612](compiler-error-c3612.md)|"*Bezeichner*': eine versiegelte Klasse kann nicht reinen virtuelle Methoden aufweisen|
|Compilerfehler Fehler C3613|Fehlende Rückgabetyp nach "("Int"ausgegangen) ->"|
|Compilerfehler Fehler C3614|Unterschiedliche Werte für Verpackungsgröße innerhalb der gleichen Klasse; Vorherige war "*Wert*", wird der neuer Wert"*Wert*"|
|[Compilerfehler Fehler C3615](compiler-error-c3615.md)|Constexpr-Funktion "*Funktion*" kann nicht in einem konstanten Ausdruck führen|
|Compilerfehler C3616|Veraltet.|
|Compilerfehler Fehler C3617|Veraltet.|
|[Compilerfehler C3618](compiler-error-c3618.md)|"*Deklaration*': eine DllImport markierte Methode kann nicht definiert werden|
|[Compilerfehler C3619](compiler-error-c3619.md)|eine Vorlage kann nicht innerhalb eines verwalteten/WinRT-Typs deklariert werden|
|Compilerfehler Fehler C3620|"*Typ*": Festlegen der Ausrichtung auf WinRT-Typen nicht zulässig ist|
|Compilerfehler Fehler C3621|"*Typ*': nur der standardmäßige Wert packen (*Anzahl*) ist für WinRT-Typen zulässig|
|[Compilerfehler C3622](compiler-error-c3622.md)|*Typ*': eine Klasse deklariert als "*Schlüsselwort*" kann nicht instanziiert werden|
|[Compilerfehler C3623](compiler-error-c3623.md)|"*Bezeichner*": Bitfelder werden in verwalteten/WinRT-Typen nicht unterstützt.|
|[Compilerfehler C3624](compiler-error-c3624.md)|"*Typ*": die Verwendung dieses Typs erfordert einen Verweis auf Assembly-Modul "*Bezeichner*"|
|[Compilerfehler C3625](compiler-error-c3625.md)|"*Klasse*": ein systemeigener Typ kann nicht abgeleitet werden, von einem verwalteten/WinRT-Typ "*Typ*"|
|[Compilerfehler C3626](compiler-error-c3626.md)|"*Bezeichner*": "*Schlüsselwort*"-Schlüsselwort kann nur verwendet werden, auf COM-Schnittstellen, Memberfunktionen und Datenmember, die Zeiger auf Delegaten|
|[Compilerfehler C3627](compiler-error-c3627.md)|Es kann nur ein Werttyp geschachtelt werden|
|[Compilerfehler C3628](compiler-error-c3628.md)|"*Klasse*': verwaltete/WinRT-Klassen unterstützen nur öffentliche Vererbung|
|Compilerfehler Fehler C3629|"*token*': eine Erfassung standardmäßig kann nur verwendet werden, am Anfang einer Erfassungsliste des Lambda-|
|[Compilerfehler C3630](compiler-error-c3630.md)|Fehler beim Verarbeiten von Token "*token*"|
|[Compilerfehler C3631](compiler-error-c3631.md)|"*Ereignis*': verwaltete/WinRT-Ereignisse können nicht überladen werden.|
|[Compilerfehler C3632](compiler-error-c3632.md)|"*Ereignis*': Unzulässiger Stil des Ereignisses für *erstellen*|
|[Compilerfehler C3633](compiler-error-c3633.md)|kann nicht definiert "*Bezeichner*"als Mitglied der verwaltete'*Klasse*"|
|[Compilerfehler C3634](compiler-error-c3634.md)|"*Member*': eine abstrakte Methode einer verwalteten/WinRT-Klasse kann nicht definiert werden.|
|Compilerfehler Fehler C3635|"*Bezeichner*": kann nicht angewendet werden, um eine verwaltete/WinRT-Klasse (verwenden Sie "*Bezeichner*" stattdessen)|
|Compilerfehler Fehler C3636|"*Bezeichner*": kann nicht in diesen Typ angewendet werden|
|[Compilerfehler C3637](compiler-error-c3637.md)|"*Funktion*': die Definition einer Friend-Funktion nicht mit einer Spezialisierung einer Funktion Vorlagen-/generische|
|[Compilerfehler C3638](compiler-error-c3638.md)|"*Operator*': das standard-Boxing und unboxing Konvertierungsoperatoren können nicht neu definiert werden|
|Compilerfehler Fehler C3639|Veraltet.|
|[Compilerfehler C3640](compiler-error-c3640.md)|"*Member*': eine referenzierte oder virtuelle Memberfunktion einer lokalen Klasse muss definiert werden|
|[Compilerfehler C3641](compiler-error-c3641.md)|"*Funktion*': ungültige Aufrufkonvention"*Konvention*"für die Funktion, die mit" / CLR "kompiliert: pure oder/clr: safe|
|[Compilerfehler C3642](compiler-error-c3642.md)|"*Funktion*': eine Funktion kann nicht aufgerufen werden, mit der __clrcall-Aufrufkonvention von systemeigenem Code|
|Compilerfehler Fehler C3643|Veraltet.|
|[Compilerfehler C3644](compiler-error-c3644.md)|"*Funktion*": die Funktion zum Generieren von verwalteten Codes kann nicht kompiliert werden.|
|[Compilerfehler C3645](compiler-error-c3645.md)|"*Funktion*": __clrcall kann nicht auf Funktionen in nativen Code kompiliert verwendet werden|
|[Compilerfehler C3646](compiler-error-c3646.md)|"*Bezeichner*": Unbekannte Überschreibungsspezifizierer|
|Compilerfehler Fehler C3647|Veraltet.|
|[Compilerfehler C3648](compiler-error-c3648.md)|Explizites Überschreibungssyntax wird für verwaltete Typen nicht unterstützt.|
|Compilerfehler Fehler C3649|Explizites Überschreibungssyntax ist mit/Zw nicht zulässig.|
|[Compilerfehler C3650](compiler-error-c3650.md)|"*Member*": kann nicht als explizite Überschreibung verwendet werden, muss eine virtuelle Memberfunktion einer Basisklasse|
|[Compilerfehler C3651](compiler-error-c3651.md)|"*Member*": kann nicht als explizite Überschreibung verwendet werden, muss ein Member einer Basisklasse|
|[Compilerfehler C3652](compiler-error-c3652.md)|"*Member*': eine Funktion, die explizit überschreibt muss virtuell sein|
|[Compilerfehler C3653](compiler-error-c3653.md)|"*Bezeichner*": kann nicht als benannte Überschreibung verwendet werden: eine Funktion, die überschrieben wurde nicht gefunden; haben Sie vergessen, den Funktionsnamen explizit mithilfe von a:: Operator?|
|[Compilerfehler C3654](compiler-error-c3654.md)|"*token*": Syntaxfehler in explizites Überschreiben|
|[Compilerfehler C3655](compiler-error-c3655.md)|"*Member*': Funktion wurde bereits explizit überschrieben.|
|[Compilerfehler C3656](compiler-error-c3656.md)|"*Schlüsselwort*": Überschreiben Spezifizierer kann nicht wiederholt werden|
|[Compilerfehler C3657](compiler-error-c3657.md)|ein Destruktor/Finalizer kann nicht explizit überschreiben oder explizit überschrieben werden|
|Compilerfehler C3658|Veraltet.|
|Compilerfehler Fehler C3659|"*Member*": Überschreibungsspezifizierer '*Schlüsselwort*"wird nicht unterstützt|
|Compilerfehler Fehler C3660|"*member1*": Blendet geerbten Member "*member2*"|
|[Compilerfehler C3661](compiler-error-c3661.md)|Explizites Überschreiben Liste keine Methoden zum Überschreiben nicht gefunden.|
|[Compilerfehler C3662](compiler-error-c3662.md)|"*Member*": Überschreibungsspezifizierer '*Schlüsselwort*"nur für Memberfunktionen von verwalteten/WinRT-Klassen zulässig.|
|Compilerfehler Fehler C3663|Veraltet.|
|Compilerfehler Fehler C3664|"*Member*": kann nicht verwendet werden, als ein explizites überschreiben möchten, benötigen Sie Zugriff auf "public" oder "protected"|
|[Compilerfehler C3665](compiler-error-c3665.md)|"*Member*": Überschreibungsspezifizierer '*Schlüsselwort*"für einen Destruktor/Finalizer nicht zulässig|
|[Compilerfehler C3666](compiler-error-c3666.md)|"*Konstruktor*": Überschreibungsspezifizierer '*Schlüsselwort*"für einen Konstruktor nicht zulässig.|
|Compilerfehler Fehler C3667|"*Attribut*": Attribut unterstützt keine paketerweiterung|
|[Compilerfehler C3668](compiler-error-c3668.md)|"*Member*': Methode mit Überschreibungsspezifizierer"Override"keine Basisklassenmethoden nicht überschreiben|
|[Compilerfehler C3669](compiler-error-c3669.md)|"*Member*": Der Überschreibungsspezifizierer 'Überschreiben' für statische Memberfunktionen oder Konstruktoren nicht zulässig|
|[Compilerfehler C3670](compiler-error-c3670.md)|"*Member*": kann nicht außer Kraft setzen Basisklassenmethode kann nicht zugegriffen werden "*Member*"|
|[Compilerfehler C3671](compiler-error-c3671.md)|"*Member*': Funktion überschreibt keine"*Member*"|
|[Compilerfehler C3672](compiler-error-c3672.md)|Pseudo-Destruktor Ausdruck kann nur als Teil eines Funktionsaufrufs verwendet werden|
|[Compilerfehler C3673](compiler-error-c3673.md)|"*Klasse*': Klasse verfügt nicht über einen Kopierkonstruktor|
|Compilerfehler Fehler C3674|standardmäßige Bibliotheksmodul wurde nicht gefunden "*Modul*"|
|[Compilerfehler C3675](compiler-error-c3675.md)|"*Funktion*": ist reserviert werden, da "*Eigenschaft*" definiert ist|
|Compilerfehler Fehler C3676|"*Klasse*": Ref-Klasse und Basisklasse haben nicht kompatiblen Attribute ' [*Attribut*] "|
|Compilerfehler Fehler C3677|Zeichenfolgenliteral nach "Operator" ein Codierung-Präfix haben kann|
|Compilerfehler Fehler C3678|Zeichenfolgenliteral nach 'Operator' die leere Zeichenfolge sein muss. "" "" "|
|Compilerfehler Fehler C3679|erwartet einen literales Suffix Bezeichner nach "Operator" "" "|
|Compilerfehler Fehler C3680|Zeichenfolgenliterale mit nicht übereinstimmenden literales Suffix Bezeichnern kann nicht verkettet werden.|
|Compilerfehler Fehler C3681|"Fallthrough": Attribut darf nur in einem einschließenden Switch-Anweisung verwendet werden|
|Compilerfehler Fehler C3682|' Operator *Bezeichner*": literal Operator/Literal-Operator-Vorlage kann nicht deklariert werden, um"C-Bindung"haben.|
|Compilerfehler Fehler C3683|unformatierte literaloperator und die Vorlage mit dem gleichen literales Suffix Bezeichner kann nicht definiert werden.|
|Compilerfehler Fehler C3684|' Operator *Bezeichner*": Deklaration von literaloperator wurde eine Ungültiger Parameter-Liste|
|Compilerfehler Fehler C3685|' Operator *Bezeichner*': Vorlage keine Funktionsparameter|
|Compilerfehler Fehler C3686|' Operator *Bezeichner*": literaloperator Vorlage muss genau ein Vorlagenparameter, der ein parameterpaket sein|
|Compilerfehler Fehler C3687|' Operator *Bezeichner*': Vorlage benötigen Nichttyp-Vorlagenparameter des Typs "Char"|
|Compilerfehler Fehler C3688|Ungültige literales Suffix "*Suffix*"; literal Operator "oder" Vorlage "Operator *Bezeichner*" wurde nicht gefunden.|
|Compilerfehler Fehler C3689|' Operator *Bezeichner*": literal Operator/Literal-Operator-Vorlage muss sich in einer globalen oder Namespacebereich|
|Compilerfehler Fehler C3690|ein ein Zeichenfolgenliteral wurde erwartet, jedoch eine benutzerdefinierte Zeichenfolge literal stattdessen gefunden|
|Compilerfehler Fehler C3691|ungültige Literalpräfix "*Präfix*"|
|Compilerfehler Fehler C3692|Veraltet.|
|Compilerfehler Fehler C3693|Veraltet.|
|Compilerfehler Fehler C3694|Veraltet.|
|Compilerfehler Fehler C3695|Veraltet.|
|Compilerfehler Fehler C3696|"*Schlüsselwort*': Verwenden Sie diese Qualifizierer kann nicht auf"%"|
|[Compilerfehler C3697](compiler-error-c3697.md)|"*Schlüsselwort*': Verwenden Sie diese Qualifizierer kann nicht auf" ^ "|
|[Compilerfehler C3698](compiler-error-c3698.md)|"*Typ*": Verwenden Sie diesen Typ kann nicht als Argument der "*Operator*"|
|[Compilerfehler C3699](compiler-error-c3699.md)|"*Operator*": Diese Dereferenzierung für Typ können keine "*Typ*"|
|Compilerfehler Fehler C3700|Veraltet.|
|[Compilerfehler C3701](compiler-error-c3701.md)|"*Funktion*": Ereignisquelle hat keine Ereignisse|
|[Compilerfehler C3702](compiler-error-c3702.md)|ATL ist erforderlich für COM-Ereignisse|
|[Compilerfehler C3703](compiler-error-c3703.md)|"*Event_handler*': eine Ereignishandlermethode muss dieselbe Speicherklasse haben, als die Quelle"*Ereignis*"|
|[Compilerfehler C3704](compiler-error-c3704.md)|"*Member*': eine Vararg-Methode kann keine Ereignisse auslösen|
|[Compilerfehler C3705](compiler-error-c3705.md)|"*Funktion*": Ereignisse-Schnittstelle wurde nicht gefunden|
|[Compilerfehler C3706](compiler-error-c3706.md)|"*Funktion*': eine COM-Schnittstelle, COM-Ereignisse ausgelöst werden muss|
|[Compilerfehler C3707](compiler-error-c3707.md)|"*Member*': Dispinterface-Methode muss eine Dispid haben|
|[Compilerfehler C3708](compiler-error-c3708.md)|"*Funktion*": falsche Verwendung von "*Schlüsselwort*"; muss ein Mitglied einer kompatiblen Ereignisquelle|
|[Compilerfehler C3709](compiler-error-c3709.md)|"*Funktion*': Ungültige Syntax für das Ereignis in __hook/__unhook angeben|
|[Compilerfehler C3710](compiler-error-c3710.md)|"*Funktion*': Ungültige Syntax zum Angeben der Ereignishandler in __hook/__unhook|
|[Compilerfehler C3711](compiler-error-c3711.md)|"*Ereignis*': eine nicht verwaltete Quelle Ereignismethode muss" void "oder einen ganzzahligen Typ zurückgeben.|
|[Compilerfehler C3712](compiler-error-c3712.md)|"*Event_handler*': eine Ereignishandlermethode muss denselben Typ wie die Quelle zurückgeben"*Ereignis*"|
|[Compilerfehler C3713](compiler-error-c3713.md)|"*Event_handler*': eine Ereignishandlermethode muss die gleiche Funktionsparameter haben, als Quelle"*Ereignis*"|
|[Compilerfehler C3714](compiler-error-c3714.md)|"*Event_handler*': eine Ereignishandlermethode muss die gleiche Aufrufkonvention haben, als die Quelle"*Ereignis*"|
|[Compilerfehler C3715](compiler-error-c3715.md)|"*Zeiger*': muss ein Zeiger auf"*Typ*"|
|Compilerfehler Fehler C3716|Veraltet.|
|[Compilerfehler C3717](compiler-error-c3717.md)|"*Member*': eine Methode, die Ereignisse auslöst, kann nicht definiert werden|
|[Compilerfehler C3718](compiler-error-c3718.md)|kann nur aufrufen ' __*Schlüsselwort*"im Kontext einer Memberfunktion der empfangenden-Klasse|
|[Compilerfehler C3719](compiler-error-c3719.md)|"*Member*': eine Ereignisquelle Schnittstelle basiert kann nur verwendet werden, für COM-Ereignisse|
|Compilerfehler Fehler C3720|"*Typ*': IDispatch kann nur auf einem dualen oder Disp-Schnittstelle implementieren|
|[Compilerfehler C3721](compiler-error-c3721.md)|"*Signatur*": Inkompatible Signatur für Ereignis|
|[Compilerfehler C3722](compiler-error-c3722.md)|ein allgemeines Ereignis ist nicht zulässig.|
|[Compilerfehler C3723](compiler-error-c3723.md)|"*Funktion*": Ereignis konnte nicht aufgelöst werden|
|[Compilerfehler C3724](compiler-error-c3724.md)|muss #include < windows.h > Verwendung von Multithreading mit Ereignissen|
|Compilerfehler Fehler C3725|Veraltet.|
|Compilerfehler Fehler C3726|Veraltet.|
|[Compilerfehler C3727](compiler-error-c3727.md)|"*Ereignis*": ein verwaltetes Ereignis muss eine Memberfunktion oder ein Datenmember, die einen Zeiger an einen Delegaten gebunden ist|
|[Compilerfehler C3728](compiler-error-c3728.md)|"*Ereignis*": Ereignis verfügt nicht über eine Raise-Methode|
|Compilerfehler Fehler C3729|Veraltet.|
|Compilerfehler C3730|Veraltet.|
|[Compilerfehler C3731](compiler-error-c3731.md)|Inkompatible Ereignis "*Ereignis*'und Handler'*Event_handler*"; Ereignisquelle und Ereignishandler müssen das gleiche Ereignis des Typs|
|[Compilerfehler C3732](compiler-error-c3732.md)|"*Schnittstelle*': eine benutzerdefinierte Schnittstelle, die COM-Ereignisse auslöst, kann nicht von IDispatch erben|
|[Compilerfehler C3733](compiler-error-c3733.md)|"*Ereignis*': Ungültige Syntax zum Angeben eines COM-Ereignisses; haben Sie vergessen, '__interface'?|
|[Compilerfehler C3734](compiler-error-c3734.md)|"*Klasse*': eine verwaltete/WinRT-Klasse kann keiner Co-Klasse|
|Compilerfehler Fehler C3735|Veraltet.|
|[Compilerfehler C3736](compiler-error-c3736.md)|"*Member*': muss eine Methode oder im Fall von verwalteten Ereignissen, optional ein Datenmember|
|[Compilerfehler C3737](compiler-error-c3737.md)|"*Bezeichner*': ein Delegat kann keine explizite Aufrufkonvention|
|[Compilerfehler C3738](compiler-error-c3738.md)|"*Konvention*": die Aufrufkonvention der expliziten Instanziierung muss übereinstimmen, der die Vorlage instanziiert wird|
|[Compilerfehler C3739](compiler-error-c3739.md)|"*Klasse*": Syntax wird nur unterstützt, wenn die "Layout\_abhängige" Event_receiver Parameter ist "true"|
|[Compilerfehler C3740](compiler-error-c3740.md)|"*Vorlage*': Vorlagen können keine Datenquelle oder Ereignisse empfangen|
|[Compilerfehler C3741](compiler-error-c3741.md)|"*Klasse*": eine Co-Klasse muss bei der "Layout\_abhängige" Event_receiver Parameter ist "true"|
|Compilerfehler Fehler C3742|"*ttoken1*": unausgeglichene Hierarchien tokensequenz in-Argument+++ des Attributs "*Attribut*', erwartet'*token2*"|
|[Compilerfehler C3743](compiler-error-c3743.md)|kann nur Hook/eine gesamte Schnittstelle lösen, wenn der Parameter 'Layout_dependent' Event_receiver "true" ist|
|[Compilerfehler C3744](compiler-error-c3744.md)|__unhook muss mindestens 3 Argumente für verwaltete Ereignisse haben.|
|[Compilerfehler C3745](compiler-error-c3745.md)|"*Funktion*': nur ein Ereignis kann"ausgelöst"|
|Compilerfehler Fehler C3746|Standard-Attribut "*Bezeichner*" kann höchstens einmal in einer Attributliste mit angezeigt|
|[Compilerfehler C3747](compiler-error-c3747.md)|Fehlender Standardwert Vorlagen-/generische Parameter: Parameter *Anzahl*|
|[Compilerfehler C3748](compiler-error-c3748.md)|"*Schnittstelle*': nicht verwaltete Schnittstellen können keine Ereignisse auslösen|
|[Compilerfehler C3749](compiler-error-c3749.md)|"*Attribut*": ein benutzerdefiniertes Attribut kann nicht innerhalb einer Funktion verwendet werden|
|Compilerfehler Fehler C3750|"*token*": Unerwartetes Token in der Attributliste|
|Compilerfehler Fehler C3751|"*Bezeichner*": Unerwarteter Bezeichner in der Attributliste|
|[Compilerfehler C3752](compiler-error-c3752.md)|"*Attribut*': Attribut kann nicht klassifiziert werden. "*Schlüsselwort*" sollte in diesem Kontext nicht verwendet werden|
|[Compilerfehler C3753](compiler-error-c3753.md)|eine generische Eigenschaft ist nicht zulässig.|
|[Compilerfehler C3754](compiler-error-c3754.md)|Delegatkonstruktor: Member-Funktion "*Member*" kann nicht aufgerufen werden eine Instanz des Typs"*Typ*"|
|[Compilerfehler C3755](compiler-error-c3755.md)|"*Bezeichner*': ein Delegat ist möglicherweise nicht definiert|
|Compiler-Fehler C3756 generiert|Veraltet.|
|Compilerfehler Fehler C3757|"*Typ*': Typ ist nicht zulässig für"Constexpr"-Funktion|
|Compilerfehler Fehler C3758|"*Member*": virtuelle Funktion, die nicht "Constexpr" deklariert werden|
|Compilerfehler Fehler C3759|"*Member*': Memberfunktion-Literal-Typ kann nicht"Constexpr"deklariert werden|
|Compilerfehler Fehler C3760|Verwenden Sie Eigenschaft in verwalteten/WinRT deklarieren __property-Schlüsselwort "*Klasse*"|
|[Compilerfehler C3761](compiler-error-c3761.md)|"*Funktion*': 'Retval' kann nur für das letzte Argument einer Funktion verwendet werden.|
|[Compilerfehler C3762](compiler-error-c3762.md)|Attribut kann nicht verarbeitet "*Attribut*"|
|[Compilerfehler C3763](compiler-error-c3763.md)|"*Typ*': 'Retval' und 'Out' kann nur auf einen Datenzeiger Typ angezeigt werden.|
|[Compilerfehler C3764](compiler-error-c3764.md)|"*Member*": Basisklassenmethode kann nicht überschrieben werden "*Member*"|
|[Compilerfehler C3765](compiler-error-c3765.md)|"*Ereignis*": ein Ereignis in einer Klasse/Struktur kann nicht definiert "*Typ*" als ein Event_receiver gekennzeichnet|
|[Compilerfehler C3766](compiler-error-c3766.md)|"*Typ*"müssen eine Implementierung für die Schnittstellenmethode bereitstellen"*Funktion*"|
|[Compilerfehler C3767](compiler-error-c3767.md)|"*Funktion*': auf mögliche Funktion(en) kann nicht zugegriffen werden|
|[Compilerfehler C3768](compiler-error-c3768.md)|die Adresse einer virtuellen Vararg-Funktion in reinen verwalteten Code nicht akzeptiert werden.|
|[Compilerfehler C3769](compiler-error-c3769.md)|"*Bezeichner*': eine geschachtelte Klasse kann nicht den gleichen Namen wie dem unmittelbar einschließenden Klasse haben|
|Compilerfehler Fehler C3770|"*Typ*": ist keine gültige base-Klasse|
|[Compilerfehler C3771](compiler-error-c3771.md)|"*Bezeichner*": Friend-Deklaration kann im nächsten Namespacebereich nicht gefunden werden|
|[Compilerfehler C3772](compiler-error-c3772.md)|"*Bezeichner*": Ungültige Friend-Vorlagendeklaration|
|Compilerfehler Fehler C3773|Bitte verwenden Sie / "await" Compilerschalter um Coroutinen zu aktivieren.|
|Compilerfehler Fehler C3774|wurde nicht gefunden "*Bereich*::*Bezeichner*": Geben Sie auch *Header* Header|
|Compilerfehler Fehler C3775|Rückgabetyp "*Funktion*"darf nicht sein"*Typ*"|
|Compilerfehler Fehler C3776|keine zurückgeben ein Ausdrucks vom Typ "void" in eine Coroutine eventuellen Rückgabetyp entsprechen, nicht als "void"|
|Compilerfehler Fehler C3777|"*Funktion*': eine Coroutine kann keine Variablenargumentliste verwenden|
|Compilerfehler Fehler C3778|Alloca: kann nicht in einem Coroutine verwendet werden|
|Compilerfehler Fehler C3779|"*Funktion*': eine Funktion, zurückgibt"*Typ*"kann nicht verwendet werden, bevor sie definiert ist|
|Compilerfehler Fehler C3780|"*Funktion*': eine Konvertierungsfunktion gibt*Typ*" kann nicht verwendet werden, bevor sie definiert ist|
|Compilerfehler Fehler C3781|"*Schlüsselwort*': nicht verwendete in einem Coroutine vom Typ"*Typ*". Entweder *Schlüsselwort* oder *Schlüsselwort* muss im zugeordneten Promise_type vorhanden sein|
|Compilerfehler Fehler C3782|*Typ*: eine Coroutine Zusage dürfen nicht beide *Schlüsselwort* und *Schlüsselwort*|
|Compilerfehler Fehler C3783|"*Bezeichner*': nicht mit einem Coroutine|
|Compilerfehler Fehler C3784|*Schlüsselwort* Ausdruck darf nicht in diesem Kontext|
|Compilerfehler Fehler C3785|die erste Vorlagenargument für'std::integer_sequence' muss ein Ganzzahltyp sein.|
|Compilerfehler Fehler C3786|Das zweite Vorlagenargument für'std::make_integer_sequence' muss eine Konstante ganze Zahl größer als oder gleich 0 (null) sein.|
|Compilerfehler Fehler C3787|den Rückgabetyp dieser Coroutine kann nicht hergeleitet werden.|
|Compilerfehler Fehler C3788|Veraltet.|
|Compilerfehler Fehler C3789|Veraltet.|
|Compilerfehler Fehler C3790|Veraltet.|
|Compilerfehler Fehler C3791|Veraltet.|
|Compilerfehler Fehler C3792|Veraltet.|
|Compilerfehler Fehler C3793|Veraltet.|
|Compilerfehler Fehler C3794|Veraltet.|
|Compilerfehler Fehler C3795|Veraltet.|
|Compilerfehler Fehler C3796|Veraltet.|
|[Compilerfehler C3797](compiler-error-c3797.md)|"*Schlüsselwort*": Ereignisdeklaration keine Überschreibungsspezifizierer (Platzieren auf Ereignis hinzufügen/entfernen/Raise-Methoden stattdessen)|
|[Compilerfehler C3798](compiler-error-c3798.md)|"*Schlüsselwort*': Eigenschaftendeklaration keine Überschreibungsspezifizierer (sollte in der Eigenschaft Get/Set-Methoden stattdessen platziert werden)|
|[Compilerfehler C3799](compiler-error-c3799.md)|indizierte Eigenschaft kann nicht über eine leere Parameterliste verfügen.|
|[Compilerfehler C3800](compiler-error-c3800.md)|"*Deklaration*": kann nicht mischen, Eigenschaften und Ereignisse|
|Compilerfehler Fehler C3801|"*Attribut*": Attribut eventuell keine Argument-Klausel|
|Compilerfehler C3802|Veraltet.|
|[Compilerfehler C3803](compiler-error-c3803.md)|"*Eigenschaft*': Eigenschaft hat einen Typ, der nicht mit einen seiner Accessoren kompatibel*Accessor*"|
|[Compilerfehler C3804](compiler-error-c3804.md)|"*Member*": die Zugriffsmethoden eine Eigenschaft müssen entweder werden alle statisch oder alle nicht statisch|
|[Compilerfehler C3805](compiler-error-c3805.md)|*token*": Unerwartetes Token erwartet entweder '} 'oder ein','|
|Compilerfehler Fehler C3806|"*token*": Unerwartetes Token erwartet entweder ein ' {' oder eine Memberinitialisierer|
|[Compilerfehler C3807](compiler-error-c3807.md)|"*Typ*": eine Klasse mit dem ComImport-Attribut kann nicht abgeleitet werden, von "*Typ*", nur schnittstellenimplementierung ist zulässig.|
|[Compilerfehler C3808](compiler-error-c3808.md)|"*Typ*": Definieren Sie eine Klasse mit dem ComImport-Attribut kann nicht Mitglied "*Member*", nur abstrahieren oder Dllimport-Funktionen sind zulässig.|
|[Compilerfehler C3809](compiler-error-c3809.md)|"*Typ*': ein verwaltete/WinRT-Typ sind keine Friend-Funktionen/Klassen/Schnittstellen|
|Compilerfehler Fehler C3810|Veraltet.|
|Compilerfehler C3811|Veraltet.|
|[Compilerfehler C3812](compiler-error-c3812.md)|'__property' muss das erste Token in einer Eigenschaftendeklaration sein.|
|[Compilerfehler C3813](compiler-error-c3813.md)|eine Eigenschaftendeklaration kann nur innerhalb der Definition eines verwalteten/WinRT-Typs verwendet werden.|
|Compilerfehler C3814|Veraltet.|
|[Compilerfehler C3815](compiler-error-c3815.md)|der Rückgabetyp der Methode "*Member*" muss der Typ des letzten Parameters des Setter entsprechen|
|[Compilerfehler C3816](compiler-error-c3816.md)|"Klasse/Struktur *Member*' wurde bereits deklariert oder definiert, die mit einem anderen verwalteten/WinRT-Modifizierer|
|[Compilerfehler C3817](compiler-error-c3817.md)|"*Deklaration*': Eigenschaft kann nur auf eine Funktion angewendet werden|
|[Compilerfehler C3818](compiler-error-c3818.md)|Array-Eigenschaftendeklaration "*Eigenschaft*"eine Indexeigenschaft keine überladen"*Eigenschaft*"|
|Compilerfehler C3819|Veraltet.|
|[Compilerfehler C3820](compiler-error-c3820.md)|"*Bezeichner*": Initialisierer müssen verwaltet werden|
|[Compilerfehler C3821](compiler-error-c3821.md)|"*Funktion*': verwaltete Typ oder die Funktion kann nicht in eine nicht verwaltete Funktion verwendet werden|
|Compilerfehler C3822|Veraltet.|
|Compilerfehler C3823|Veraltet.|
|[Compilerfehler C3824](compiler-error-c3824.md)|"*Typ*': Dieser Typ darf nicht in diesem Kontext (Funktionsparameter, Rückgabetyp oder einen statischen Member)|
|[Compilerfehler C3825](compiler-error-c3825.md)|"*Typ*': eine verwaltete/WinRT-Klasse unterstützt nur verwaltete/WinRT-Ereignisse|
|Compilerfehler C3826|Veraltet.|
|Compilerfehler Fehler C3827|Standard-Attribut "veraltet" möglicherweise keine Argumente oder ein Zeichenfolgenliteral, Beschreibung der Ursache|
|[Compilerfehler C3828](compiler-error-c3828.md)|Positionierungsargumente können nicht angegeben werden, für eine "*Schlüsselwort*"Ausdruck für den Typ"*Typ*"|
|Compilerfehler Fehler C3829|Standard-Attribut "Noreturn" kann nur auf Funktionen angewendet werden|
|[Compilerfehler C3830](compiler-error-c3830.md)|"*Typ1*": kann nicht Vererben "*Typ2*", Werttypen können nur von Schnittstellenklassen erben|
|[Compilerfehler C3831](compiler-error-c3831.md)|"*Bezeichner*": "*Typ*' darf keine festen Datenmember oder eine Memberfunktion, die einen festen Zeiger zurückgibt|
|[Compilerfehler C3832](compiler-error-c3832.md)|"*Typelib*': Typ-Bibliothek, als ob sie für 32-Bit-Zeiger; erstellt wurde ändern den Qualifizierer 'Ptrsize'|
|[Compilerfehler C3833](compiler-error-c3833.md)|"*Typ*": Ungültiger Zieltyp für *Bezeichner*|
|[Compilerfehler C3834](compiler-error-c3834.md)|Unzulässige explizite Umwandlung zu einem festen Zeiger; Verwenden Sie stattdessen eine angeheftete lokale Variable.|
|Compilerfehler Fehler C3835|Veraltet.|
|[Compilerfehler C3836](compiler-error-c3836.md)|ein statischer Konstruktor ist nicht zulässig, eine Memberinitialisiererliste haben|
|Compilerfehler Fehler C3837|Attribute sind in diesem Kontext nicht zulässig.|
|[Compilerfehler C3838](compiler-error-c3838.md)|kann nicht Vererben "*Typ*"|
|[Compilerfehler C3839](compiler-error-c3839.md)|Ausrichtung in einem verwalteten/WinRT-Typ kann nicht geändert werden.|
|Compilerfehler C3840|Veraltet.|
|Compilerfehler Fehler C3841|Veraltet.|
|[Compilerfehler C3842](compiler-error-c3842.md)|"*Bezeichner*': 'const' und 'volatile' Qualifizierer für Memberfunktionen eines verwalteten/WinRT-Typen werden nicht unterstützt.|
|Compilerfehler Fehler C3843|"*Bezeichner*": Ref-Qualifizierer für Memberfunktionen eines verwalteten/WinRT-Typen werden nicht unterstützt.|
|Compilerfehler Fehler C3844|"*Bezeichner*": Symbol aus kann nicht importiert "*Quelle*': als*Bezeichner*" ist bereits im aktuellen Bereich vorhanden.|
|Compiler-Fehler C3845 generiert|Veraltet.|
|[Compilerfehler C3846](compiler-error-c3846.md)|"*Bezeichner*": kann nicht importiert Symbol aus "*Quelle*': als*Bezeichner*'wurde bereits importiert aus einer anderen Assembly'*Assembly*'|
|Compilerfehler Fehler C3847|Veraltet.|
|[Compilerfehler C3848](compiler-error-c3848.md)|Ausdruck mit einem Typ '*Typ*"würden verlieren einige Const-Volatile-Qualifizierer für den Aufruf"*Bezeichner*"|
|[Compilerfehler C3849](compiler-error-c3849.md)|Funktionstypen-Aufruf für einen Ausdruck vom Typ "*Typ*" const "und/oder" volatile-Qualifizierer für alle Verlust von *Anzahl* verfügbar operatorüberladungen|
|[Compilerfehler C3850](compiler-error-c3850.md)|"*token*': eine universelle Zeichenname gibt ein ungültiges Zeichen an.|
|[Compilerfehler C3851](compiler-error-c3851.md)|"*token*': eine universelle Zeichenname darf kein Zeichen im Basiszeichensatz kennzeichnen|
|[Compilerfehler C3852](compiler-error-c3852.md)|"*Member*'mit Typ'*Typ*": Bei diesem Member von aggregierter Initialisierung konnte nicht initialisiert werden|
|[Compilerfehler C3853](compiler-error-c3853.md)|'=': Unzulässige wird erneut initialisiert werden, ein Verweis oder die Zuweisung über eine Reference-Funktion|
|[Compilerfehler C3854](compiler-error-c3854.md)|Ausdruck links von '=' wird als Funktion ausgewertet. Kann nicht an eine Funktion zuweisen (eine Funktion ist kein l-Wert)|
|[Compilerfehler C3855](compiler-error-c3855.md)|"*Funktion*": Vorlagen-/generische Parameter "*Bezeichner*" ist nicht kompatibel mit der Deklaration|
|[Compilerfehler C3856](compiler-error-c3856.md)|"*Klasse*': Klasse ist eine Klasse Vorlagen-/generische|
|[Compilerfehler C3857](compiler-error-c3857.md)|"*Vorlage*': mehrere Vorlagen-/generische Parameterlisten sind nicht zulässig.|
|[Compilerfehler C3858](compiler-error-c3858.md)|"*Bezeichner*": kann nicht im aktuellen Bereich nicht erneut deklariert werden|
|[Compilerfehler C3859](compiler-error-c3859.md)|Virtueller Speicherbereich für PCH wurde überschritten; Kompilieren Sie erneut mit einer Befehlszeilenoption von "-Zm*Anzahl*' oder höher|
|[Compilerfehler C3860](compiler-error-c3860.md)|Vorlagen-/generische Argumentliste folgt Vorlagen-/generische Klassennamen muss Parameter in der Reihenfolge, in der Parameterliste Vorlagen-/generische verwendet auflisten.|
|[Compilerfehler C3861](compiler-error-c3861.md)|"*Bezeichner*': Bezeichner wurde nicht gefunden.|
|[Compilerfehler C3862](compiler-error-c3862.md)|"*Funktion*": kann nicht kompiliert werden eine nicht verwaltete Funktion mit/clr: pure oder/clr: safe|
|Compilerfehler Fehler C3863|Arraytyp "*Typ*" kann nicht zugewiesen werden|
|Compilerfehler Fehler C3864|Veraltet.|
|[Compilerfehler C3865](compiler-error-c3865.md)|"*Schlüsselwort*": kann nur für systemeigene Memberfunktionen verwendet werden|
|[Compilerfehler C3866](compiler-error-c3866.md)|Destruktor/Finalizer-Aufruf ohne Argumentliste|
|[Compilerfehler C3867](compiler-error-c3867.md)|"*Funktion*': nicht standardmäßige Syntax; verwenden Sie '&', um einen Zeiger auf Member erstellen|
|[Compilerfehler C3868](compiler-error-c3868.md)|"*Typ*": Einschränkungen für generische Parameter "*Parameter*" unterscheiden sich von denen in der Deklaration|
|[Compilerfehler C3869](compiler-error-c3869.md)|Gcnew-Einschränkung ist nicht leere Parameter Liste '(')|
|Compilerfehler Fehler C3870|"*Parameter*": "__declspec (*Spezifizierer*)" kann nur auf Parameter vom ganzzahligen Typ angewendet werden|
|Compilerfehler Fehler C3871|"*Parameter*": "__declspec(guard(overflow))" wird nur unterstützt, auf die ersten 64 Parameter einer Funktion|
|[Compilerfehler C3872](compiler-error-c3872.md)|"0 X*Wert*": Dieses Zeichen ist in einem Bezeichner nicht zulässig.|
|[Compilerfehler C3873](compiler-error-c3873.md)|"0 X*Wert*": Dieses Zeichen nicht als erstes Zeichen eines Bezeichners zulässig ist|
|[Compilerfehler C3874](compiler-error-c3874.md)|Rückgabetyp "*Bezeichner*'muss'*Typ1*"anstelle von"*Typ2*"|
|Compilerfehler Fehler C3875|Aufruf einer nicht statischen Memberfunktion fehlt die Argumentliste|
|Compilerfehler Fehler C3876|Veraltet.|
|Compilerfehler Fehler C3877|Veraltet.|
|Compilerfehler Fehler C3878|Veraltet.|
|Compilerfehler Fehler C3879|"*Member*': nicht mit ein Initonly-Datenmember|
|[Compilerfehler C3880](compiler-error-c3880.md)|"*Member*': nicht mit ein literal-Datenmember|
|Compilerfehler Fehler C3881|Konstruktor kann nur von direkten Basisklasse erben werden.|
|Compilerfehler Fehler C3882|"*Klasse*': Konstruktor hat bereits geerbt von"*Klasse*"|
|Compilerfehler C3883|"*Member*": ein statischer Datenmember Initonly muss initialisiert werden|
|Compilerfehler Fehler C3884|"*Typ*": ein Array von Unbekannte Größe kann nicht initialisiert mit dem Wert sein.|
|Compilerfehler Fehler C3885|"*Typ*": ein Array von Unbekannte Größe kann nicht mit einer leeren Initialisiererliste initialisiert werden|
|[Compilerfehler C3886](compiler-error-c3886.md)|"*Member*": Ein literal-Datenmember muss initialisiert werden|
|[Compilerfehler C3887](compiler-error-c3887.md)|"*Member*": Initialisierer für ein literal-Datenmember muss ein konstanter Ausdruck sein|
|[Compilerfehler C3888](compiler-error-c3888.md)|"*Member*": der diesem literal-Datenmember zugeordnete Konstantenausdruck wird nicht von C + c++ / CLI|
|Compilerfehler Fehler C3889|Veraltet.|
|[Compilerfehler C3890](compiler-error-c3890.md)|"*Member*': Sie können die Adresse von einem literal-Datenmember nicht übernehmen|
|[Compilerfehler C3891](compiler-error-c3891.md)|"*Member*": Ein literal-Datenmember kann nicht als ein l-Wert verwendet werden|
|[Compilerfehler C3892](compiler-error-c3892.md)|"*Variable*': Sie können eine Variable, die eine Konstante ist zuweisen|
|[Compilerfehler C3893](compiler-error-c3893.md)|"*Member*": l-Wert-Verwendung von Initonly-Datenmember ist nur zulässig, in einem Instanzenkonstruktor der Klasse*Klasse*"|
|[Compilerfehler C3894](compiler-error-c3894.md)|"*Member*': Verwendung statischer Datenmember Initonly l-Wert ist nur zulässig, in den Konstruktor der Klasse Klasse*Klasse*"|
|[Compilerfehler C3895](compiler-error-c3895.md)|"*Member*": *Typ* Datenmember darf nicht 'volatile' sein|
|[Compilerfehler C3896](compiler-error-c3896.md)|"*Member*': Ungültige Initialisierer: diesem literal-Datenmember kann nur mit"Nullptr"initialisiert werden|
|Compiler-Fehler C3897 generiert|Veraltet.|
|[Compilerfehler C3898](compiler-error-c3898.md)|"*Member*": *Typ* Datenmember können nur Mitglieder von verwalteten Typen sein|
|[Compilerfehler C3899](compiler-error-c3899.md)|"*Member*": l-Wert-Verwendung von Initonly-Datenmember ist nicht zulässig, direkt innerhalb eines parallelen Bereichs in Klasse*Klasse*"|
|[Compilerfehler C3900](compiler-error-c3900.md)|"*Member*": im aktuellen Bereich nicht zulässig.|
|[Compilerfehler C3901](compiler-error-c3901.md)|"*Funktion*": Rückgabetyp benötigen "*Typ*"|
|[Compilerfehler C3902](compiler-error-c3902.md)|"*Funktion*': Typ des letzten Parameters muss '*Typ*"|
|[Compilerfehler C3903](compiler-error-c3903.md)|"*Eigenschaft*": ist nicht festgelegt haben, oder get-Methode|
|[Compilerfehler C3904](compiler-error-c3904.md)|"*Eigenschaft*": müssen angeben, *Anzahl* Parameter|
|Compilerfehler Fehler C3905|nicht ausgerichtete Zugriffe werden nicht unterstützt, für die systeminternen Typ "*Typ*"|
|Compilerfehler Fehler C3906|Grundtyps "*Typ*" ist nicht unterstützter Typ zurückgeben oder Argument für Vararg oder ohne Prototyp-Funktion|
|Compilerfehler Fehler C3907|Veraltet.|
|[Compilerfehler C3908](compiler-error-c3908.md)|die Zugriffsebene ist weniger restriktiv als die von "*Bezeichner*"|
|[Compilerfehler C3909](compiler-error-c3909.md)|eine verwaltete/WinRT Ereignisdeklaration muss in verwalteten/WinRT-Typs auftreten.|
|[Compilerfehler C3910](compiler-error-c3910.md)|"*Ereignis*": Schnittstellenmember müssen definieren "*Member*"|
|[Compilerfehler C3911](compiler-error-c3911.md)|"*Member*': Funktion muss einen Typ aufweisen"*Typ*"|
|[Compilerfehler C3912](compiler-error-c3912.md)|"*Ereignis*': Typ des Ereignisses muss ein Delegattyp sein|
|[Compilerfehler C3913](compiler-error-c3913.md)|eine Standardeigenschaft muss indiziert werden|
|[Compilerfehler C3914](compiler-error-c3914.md)|eine Standardeigenschaft kann nicht statisch sein.|
|[Compilerfehler C3915](compiler-error-c3915.md)|"*Bezeichner*' hat keine indizierte Standardeigenschaft (Klassenindexer)|
|Compilerfehler Fehler C3916|Veraltet.|
|[Compilerfehler C3917](compiler-error-c3917.md)|"*token*": veraltet *erstellen* Deklarationsstil (wollten Sie verwenden "[" "]" stattdessen?)|
|[Compilerfehler C3918](compiler-error-c3918.md)|Die Syntax muss "*Bezeichner*" einen Datenmember werden|
|[Compilerfehler C3919](compiler-error-c3919.md)|"*Funktion*': Funktion muss einen Typ aufweisen"*Return_type* (*Typ*) "|
|[Compilerfehler C3920](compiler-error-c3920.md)|"*Operator*': keine definieren eine Postfix-Inkrement/Dekrement CLR/WinRT-Operator Aufrufen des Postfix CLR/WinRT-Operator Ruft das entsprechende Präfix CLR/WinRT-Operator (Op_Increment/Op_Decrement), jedoch mit Postfix Semantik|
|Compilerfehler C3921|Veraltet.|
|Compilerfehler Fehler C3922|Veraltet.|
|[Compilerfehler C3923](compiler-error-c3923.md)|"*Member*": lokale Klasse, Struktur oder union Definitionen sind nicht zulässig, in einer Memberfunktion einer verwalteten/WinRT-Klasse|
|Compilerfehler Fehler C3924|Fehler im Argument #*Anzahl* der Konstruktoraufruf für Delegat '*Konstruktor*":|
|Compilerfehler Fehler C3925|erwartet eine Schleife (für durchführen, oder while) folgenden "*Richtlinie*" Richtlinie|
|Compilerfehler Fehler C3926|Ungültige Konstante in "parallel"-Direktive|
|Compilerfehler Fehler C3927|"->": nachstehendem Rückgabetyp darf nicht nach einem funktionsdeklarator|
|Compilerfehler Fehler C3928|"->": nachstehendem Rückgabetyp darf nicht nach einem Deklarator in Klammern|
|Compilerfehler Fehler C3929|Veraltet.|
|Compilerfehler Fehler C3930|"*Funktion*': keine überladene Funktion hat einschränkungsspezifizierer, die kompatibel mit dem Ambiente-Kontext sind"*Kontext*"|
|Compilerfehler Fehler C3931|"*Typ*": kann nicht aufgerufen werden, der einschränkungsspezifizierer hat, die mit dem Ambiente-Kontext nicht kompatibel sind|
|Compilerfehler Fehler C3932|Veraltet.|
|Compilerfehler Fehler C3933|"*Klasse*": der Destruktor einschränkungsspezifizierer müssen die Vereinigung der Einschränkungen für alle Konstruktoren abdecken|
|Compilerfehler Fehler C3934|eine Funktion, die in irgendeiner Form von "Main" ist keine einschränkungsspezifizierer als restrict(cpu)|
|Compilerfehler Fehler C3935|"*Bezeichner*": Neudefinition; überlappende einschränkungsspezifizierer|
|Compilerfehler Fehler C3936|"*Bezeichner*": Unbekannte einschränkungsspezifizierer|
|Compilerfehler Fehler C3937|leere einschränkungsspezifizierer ist nicht zulässig.|
|Compilerfehler Fehler C3938|"*Bezeichner*': mehrere einschränkungsspezifizierer werden unter" extern "\042C\042 Funktionen nicht unterstützt.|
|Compilerfehler Fehler C3939|"*Bezeichner*': Zeiger auf Memberfunktionen, Funktionszeigern, die Verweise auf Funktionen mit"Amp"einschränkungsspezifizierer sind nicht zulässig.|
|Compilerfehler Fehler C3940|"*Bezeichner*': Bezeichner nicht gefunden - Compilerfehler und -Bibliotheksversionen möglich übereinstimmen. Stellen Sie sicher vccorlib.h/.lib, vccorlib120.dll und c1xx.dll Übereinstimmung|
|Compilerfehler Fehler C3941|"*Bedingung*": erfordert "/ Clr" Befehlszeilenoption|
|Compilerfehler Fehler C3942|Veraltet.|
|Compilerfehler Fehler C3943|Veraltet.|
|Compilerfehler Fehler C3944|Veraltet.|
|Compilerfehler Fehler C3945|"*Typ*": kann nicht ausgelöst oder ein Winrt-Objekt, das von Platform:: Exception abgeleitet werden nicht abgefangen|
|Compilerfehler Fehler C3946|"*Typ*": Typeid kann nicht in diesen Typ angewendet werden|
|Compilerfehler Fehler C3947|"*Typeid*": Typeid kann nicht angewendet werden, um eine paketerweiterung|
|Compilerfehler Fehler C3948|"*Schlüsselwort*': eine paketerweiterung darf nicht in diesem Kontext|
|Compilerfehler Fehler C3949|eine paketerweiterung, "...", kann nicht in eine in Klammern gesetzte abstrakten Deklarator stehen.|
|Compilerfehler Fehler C3950|Veraltet.|
|Compilerfehler Fehler C3951|Pointer-to-Member in projizierten WinRT-Typs können keine "*Typ*". Verwenden Sie stattdessen einen Delegaten.|
|Compilerfehler Fehler C3952|"*Typ*": WinRT unterstützt nicht "in/out"-Arrays. Verwenden "const Array<T>^' für 'in' und ' WriteOnlyArray<T>" oder "Array<T>^ *' für 'Out' von öffentlichen APIs|
|Compilerfehler Fehler C3953|Können keine verwalteten Klasse*Typ*"in WinRT-Modul.|
|Compilerfehler Fehler C3954|'*Typ*": ein Array aus einer veröffentlichten Methode zurückgegeben wird, auf WinRT-Typs muss verwenden Sie das Format" Array<T>^'|
|Compilerfehler Fehler C3955|"*Typ*": ein öffentlicher Konstruktor darf keine 'Out'-Parameter enthalten oder "WriteOnlyArray<T>"|
|Compilerfehler Fehler C3956|"*Typ*': Typ ist als exklusive, markiert"*Typ*"und kann nicht verwendet werden, als Basis von"*Derived_type*"|
|Compilerfehler Fehler C3957|"*Typ*": kann nicht verwendet 'new' für ein WinRT geben; verwenden Sie stattdessen "Ref new"|
|Compilerfehler Fehler C3958|"*Typ*": "Gcnew" kann nicht verwendet werden, auf ein WinRT geben; verwenden Sie stattdessen "Ref new"|
|Compilerfehler Fehler C3959|"Ref new" kann nur verwendet werden, um ein Objekt mit WinRT-Typs zu erstellen.|
|Compilerfehler Fehler C3960|Veraltet.|
|Compilerfehler Fehler C3961|statischer Konstruktor wird nicht unterstützt.|
|Compilerfehler Fehler C3962|generische Klasse wird nicht unterstützt.|
|Compilerfehler Fehler C3963|ein mehrdimensionales Array wird nicht unterstützt.|
|Compilerfehler Fehler C3964|Verzweigte Arrays wird nicht unterstützt.|
|Compilerfehler Fehler C3965|Parameterarray wird nicht unterstützt.|
|Compilerfehler Fehler C3966|"*Funktion*': generische Funktion wird nicht unterstützt.|
|Compilerfehler Fehler C3967|Fehler beim Importieren von "*Bezeichner*"aus dem Modul"*Modul*"|
|Compilerfehler Fehler C3968|Das Token "*token*' ist kein gültiger Modul Name Trennzeichen Punkt ('. ') stattdessen|
|Compilerfehler Fehler C3969|Inkonsistente Modulnamen: "*module1*'und'*module1*"|
|Compilerfehler Fehler C3970|"*Bezeichner*": "*Schlüsselwort*" kann nur auf "Verweisklasse" oder "Ref Struct" im globalen Gültigkeitsbereich oder Namespacebereich angewendet werden|
|Compilerfehler Fehler C3971|"*Typ*": partielle Definition kann nicht angezeigt werden, nach der vollständigen Definition|
|Compilerfehler Fehler C3972|"*Typ*': 'partial' kann nur auf Klassendeklarationen oder-Definitionen angewendet werden|
|Compilerfehler Fehler C3973|Veraltet.|
|Compilerfehler Fehler C3974|Veraltet.|
|Compilerfehler Fehler C3975|"Klasse/Struktur *Bezeichner*' wurde bereits deklariert oder definiert, die mit einem anderen Modifizierer|
|Compilerfehler Fehler C3976|"*Bezeichner1*"muss deklariert werden als "public" um verwenden"*Bezeichner2*"|
|Compilerfehler Fehler C3977|Verwendung erfordert einen Verweis auf eine Assembly, die definiert "*Bezeichner*"|
|Compilerfehler Fehler C3978|"*Bezeichner*': eine statische Eigenschaft darf nicht als Mitglied einer WinRT-Schnittstelle oder eines Werttyps|
|Compilerfehler Fehler C3979|"*Typ*": Verwenden von Attribut "*Attribut*"anstelle von"*Wert*"|
|Compilerfehler Fehler C3980|"*Typ*" kann nicht in Metadaten ausgegeben werden|
|Compilerfehler Fehler C3981|"*Typ*": ein Werttyp sind keine statischen Datenelemente*Bezeichner*"|
|Compilerfehler Fehler C3982|"*Typ*": ein Werttyp nicht öffentlichen Datenmember sind keine*Bezeichner*"|
|Compilerfehler Fehler C3983|"*Typ*": ein Werttyp sind keine öffentlichen nicht-Datenmember*Bezeichner*"|
|Compilerfehler Fehler C3984|"*Typ*": ein Werttyp sind keine öffentlichen Datenmember*Bezeichner*"|
|Compilerfehler Fehler C3985|"*Bezeichner*': Signatur des öffentlichen Members enthält den privaten Typ '*Member*"|
|Compilerfehler Fehler C3986|"*Bezeichner*": die Signatur des öffentlichen Members enthält systemeigenen Typ "*Member*"|
|Compilerfehler Fehler C3987|"*Bezeichner*": die Signatur des öffentlichen Members enthält systemeigenen Typ "*Typ*"|
|Compilerfehler Fehler C3988|"*Typ*": ein systemeigener Typ kann nicht öffentlich sein|
|Compilerfehler Fehler C3989|"*Typ*": ein geschachtelter Typ nicht öffentlich sein|
|Compilerfehler Fehler C3990|"*Typ*": Attribut '*Attribut*"kann nicht privat oder geschachtelte|
|Compilerfehler Fehler C3991|"*Typ*": eine nicht öffentlicher oder verschachtelte-Schnittstelle kann nicht implementiert "*Schnittstelle*"|
|Compilerfehler Fehler C3992|"*Bezeichner*": die Signatur des öffentlichen Members enthält einen ungültigen Typ "*Typ*"|
|Compilerfehler Fehler C3993|"*Typ*": ein Werttyp muss mindestens ein öffentliches Feld enthalten|
|Compilerfehler Fehler C3994|"*Typ*": ein Werttyp kann keine Schnittstellen implementieren oder virtuelle Funktionen aufweisen|
|Compilerfehler Fehler C3995|"*Typ*": ein Werttyp keine Ereignismember*Bezeichner*"|
|Compilerfehler C3996|Veraltet.|
|Compilerfehler Fehler C3998|"C ++*Version*': nicht unterstützte Version von C++; direktionales" C ++*Version*"|
|Compilerfehler Fehler C3999|Unbekannte Fehler wählen Sie den technischen Supportbefehl im Visual C++-Hilfemenü, oder öffnen Sie den technischen Support-Hilfedatei für Weitere Informationen|
